<!DOCTYPE html>
<html lang="en" class="no-js">

<head>

  <!--- basic page needs
    ================================================== -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Han Meerholz</title>

  <script>
    document.documentElement.classList.remove('no-js');
    document.documentElement.classList.add('js');
  </script>

  <!-- CSS
    ================================================== -->
  <link rel="stylesheet" href="css/vendor.css">
  <link rel="stylesheet" href="css/styles.css">
  <link rel="stylesheet" href="css/highlight/atom-one-dark.min.css">

  <!-- favicons
    ================================================== -->
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">

</head>


<body id="top">


  <!-- preloader
    ================================================== -->
  <div id="preloader">
    <div id="loader" class="line"></div>
  </div>


  <!-- page wrap
    ================================================== -->
  <div id="page" class="s-pagewrap">


    <!-- # site header 
        ================================================== -->
    <header id="masthead" class="s-header">

      <div class="s-header__block">
        <div class="s-header__branding">
          <p class="site-title">
            <a href="index.html" rel="home">Han</a>
          </p>
        </div>

        <a class="s-header__menu-toggle" href="#0"><span>Menu</span></a>
      </div> <!-- end s-header__block -->

      <div class="row s-header__nav-wrap">
        <ul class="s-header__social">
          <li>
            <a href="https://www.linkedin.com/in/han-meerholz/">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 448 512"
                style="fill: rgba(0, 0, 0, 1);transform: ;msFilter:;">
                <path fill-rule="evenodd" clip-rule="evenodd"
                  d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z">
                </path>
              </svg>

              <span class="u-screen-reader-text">LinkedIn</span>
            </a>
          </li>
          <li>
            <a href="https://github.com/HanMeerholz/">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                style="fill: rgba(0, 0, 0, 1);transform: ;msFilter:;">
                <path fill-rule="evenodd" clip-rule="evenodd"
                  d="M12.026 2c-5.509 0-9.974 4.465-9.974 9.974 0 4.406 2.857 8.145 6.821 9.465.499.09.679-.217.679-.481 0-.237-.008-.865-.011-1.696-2.775.602-3.361-1.338-3.361-1.338-.452-1.152-1.107-1.459-1.107-1.459-.905-.619.069-.605.069-.605 1.002.07 1.527 1.028 1.527 1.028.89 1.524 2.336 1.084 2.902.829.091-.645.351-1.085.635-1.334-2.214-.251-4.542-1.107-4.542-4.93 0-1.087.389-1.979 1.024-2.675-.101-.253-.446-1.268.099-2.64 0 0 .837-.269 2.742 1.021a9.582 9.582 0 0 1 2.496-.336 9.554 9.554 0 0 1 2.496.336c1.906-1.291 2.742-1.021 2.742-1.021.545 1.372.203 2.387.099 2.64.64.696 1.024 1.587 1.024 2.675 0 3.833-2.33 4.675-4.552 4.922.355.308.675.916.675 1.846 0 1.334-.012 2.41-.012 2.737 0 .267.178.577.687.479C19.146 20.115 22 16.379 22 11.974 22 6.465 17.535 2 12.026 2z">
                </path>
              </svg>
              <span class="u-screen-reader-text">Github</span>
            </a>
          </li>
          <li>
            <a href="https://theanachronist.itch.io/">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 32 32"
                style="fill: rgba(0, 0, 0, 1);transform: ;msFilter:;">
                <path fill-rule="evenodd" clip-rule="evenodd"
                  d="M 16 5 C 12.748 5 8.3121094 5.0508594 7.4121094 5.1308594 C 6.4021094 5.7368594 4.4028125 8.0309531 4.3828125 8.6269531 L 4.3828125 9.6269531 C 4.3828125 10.889953 5.5657188 12 6.6367188 12 C 7.9197187 12 8.9902344 10.929969 8.9902344 9.6679688 C 8.9902344 10.929969 10.0305 12 11.3125 12 C 12.6055 12 13.605469 10.930969 13.605469 9.6679688 C 13.605469 10.929969 14.695281 12 15.988281 12 L 16.009766 12 C 17.302766 12 18.392578 10.930969 18.392578 9.6679688 C 18.392578 10.929969 19.402547 12 20.685547 12 C 21.968547 12 23.009766 10.930969 23.009766 9.6679688 C 23.009766 10.929969 24.080281 12 25.363281 12 C 26.434281 12 27.615234 10.889953 27.615234 9.6269531 L 27.615234 8.6269531 C 27.595234 8.0309531 25.595938 5.7368594 24.585938 5.1308594 C 21.443938 5.0198594 19.252 5 16 5 z M 13.550781 11.742188 C 12.497781 13.552188 9.8523125 13.573906 8.8203125 11.753906 C 8.1903125 12.845906 6.7642969 13.267547 6.1542969 13.060547 C 5.9762969 14.959547 5.8534844 24.70875 7.1464844 26.34375 C 10.943484 27.22875 21.164516 27.20975 24.853516 26.34375 C 26.348516 24.81975 26.013703 14.821547 25.845703 13.060547 C 25.235703 13.267547 23.809453 12.845906 23.189453 11.753906 C 22.146453 13.573906 19.501219 13.552188 18.449219 11.742188 C 18.124219 12.332187 17.367 13.109375 16 13.109375 C 14.997 13.148375 14.051781 12.607187 13.550781 11.742188 z M 11.419922 14 C 12.219922 14 12.950078 14.000469 13.830078 14.980469 C 15.280078 14.830469 16.719922 14.830469 18.169922 14.980469 C 19.059922 14.010469 19.780078 14.009766 20.580078 14.009766 C 23.160078 14.009766 23.780937 17.819609 24.710938 21.099609 C 25.550938 24.149609 24.429062 24.230469 23.039062 24.230469 C 20.969062 24.150469 19.820313 22.650625 19.820312 21.140625 C 17.890313 21.460625 14.809688 21.580625 12.179688 21.140625 C 12.179688 22.650625 11.030938 24.150469 8.9609375 24.230469 C 7.5709375 24.230469 6.4490625 24.149609 7.2890625 21.099609 C 8.2190625 17.799609 8.8399219 14.009766 11.419922 14.009766 L 11.419922 14 z M 16 16.876953 C 16 16.876953 14.306 18.439375 14 18.984375 L 15.107422 18.943359 L 15.107422 19.910156 C 15.107422 19.968156 15.926 19.917969 16 19.917969 C 16.447 19.934969 16.892578 19.951156 16.892578 19.910156 L 16.892578 18.943359 L 18 18.984375 C 17.694 18.438375 16 16.876953 16 16.876953 z" />
              </svg>
              <span class="u-screen-reader-text">Itch.io</span>
            </a>
          </li>
        </ul> <!-- end s-header__social -->
      </div> <!-- end s-header__nav-wrap -->
    </header> <!-- end s-header -->

    <section id="blog" class="s-about">
      <div class="row">
        <div class="column lg-12">
          <h1>Bequestor: <br> A Versatile Quest System</h1>

          <div class="images_container">
            <div class="image_container">
              <img src="images/blog/quest_creator_full_quest.png"
                alt="Quest creation window with visible quest with multiple prerequisites and objectives, some of which are collapsed; the second objective has custom parameters and is dependent on the first.">
            </div>
            <div class="image_container">
              <img src="images/blog/quest_sample_game.png" alt="Quest game window showing quest progression.">
            </div>
          </div>

          <h2>Introduction</h2>

          <p>
            Quest systems are omnipresent in videogames, and have evolved far beyond the simple "kill 10 goblins in the
            woods"
            present in classic RPGs. Nowadays, you can find some kind of quest system in anything from modern RPGs like
            Cyberpunk 2077 to Metroidvanias like Hollow Knight: Silksong; from sandbox games like Minecraft, to Discord
            (yes,
            the social platform).
          </p>

          <p>
            <em>But how do you go about creating your own quest system for a game? How do you even define a quest in the
              first place?</em>
          </p>

          <p>
            To answer this, I have created my own quest design tool and quest system C++ library, <em>Bequestor</em>.
            In this blog post, I will show how the tool works and how you could implement a similar tool for yourself.
          </p>

          <p>
            In this version of the blog post, I will only include the technically relevant parts. For the full user
            guide, see the <a href="https://hanmeerholz.github.io/bequestor_devlog.html">website</a>. The <a
              href="#q_under_the_hood">under the hood</a> section outlines the implementation details of
            the <em>Bequestor</em> library. I have also left the <a href="#q_conclusion">conclusion</a> and <a
              href="#q_references">references</a> in.
          </p>

          <h2 id="q_under_the_hood" class="collapsible">Under the Hood</h2>
          <div class="collapsible_content">
            <h3>Import</h3>

            <p>
              Under the hood, importing a quest is done using the <code class="hljs">nlohmann/json</code> library [1].
              My JSON reader is mostly hardcoded based on the quest JSON structure. The conversion from string to enum
              can easily be done using the <code class="hljs">NLOHMANN_JSON_SERIALIZE_ENUM</code> macro.
            </p>

            <pre><code>NLOHMANN_JSON_SERIALIZE_ENUM(QuestStatus,
  {{QuestStatus::UNAVAILABLE, "Unavailable"},
   {QuestStatus::CAN_START, "Can Start"},
   {QuestStatus::STARTED, "Started"},
   {QuestStatus::CAN_FINISH, "Can Finish"},
   {QuestStatus::FINISHED, "Finished"},
   {QuestStatus::CANCELLED, "Cancelled"}});</code></pre>

            <p>
              Reading in the JSON itself, in turn, is quite easy with the nlohmann library. Below is my <code
                class="hljs">ReadQuests()</code> function implementation:
            </p>

            <pre><code>vector&lt;Quest> JsonReader::ReadQuests(string const& filepath /*...*/)
{
  vector&lt;Quest> quests = {};
  ifstream f(filepath);

  if (!f.is_open())
  {
    cerr &lt;&lt; "error opening file." &lt;&lt; endl;
    return quests; 
  }

  json questsJson = json::parse(f);
  for (json const& questJson : questsJson["quests"])
  { 
    Quest quest; quest.id = questJson["id"].get&lt;int>();
    quest.name = questJson["name"];
    quest.description = questJson["description"];
    //(...)
    quests.push_back(quest);
    shared_ptr&lt;Quest> questPtr = make_shared&lt;Quest>(quest);
  }

return quests;
};</code></pre>

            <h3>PrerequisiteChecker Implementation</h3>

            <p>
              Under the hood, to keep track of different prerequisite checkers, I use a <em>Command Pattern</em> [2].
              The base class <code class="hljs">PrerequisiteChecker</code> is an interface with a single virtual <code
                class="hljs">IsSatisfied()</code> function that returns a boolean. This interface is implemented for
              specific checkers, such as the <code class="hljs">IdAmountPrereqChecker</code> class. This takes a <code
                class="hljs">std::function&lt;unsigned int(std::string const&)> idAmountQuery</code> and is used for
              the
              item <code class="hljs">PrerequisiteChecker</code>. The other preset <code
                class="hljs">PrerequisiteCheckers</code>s work similarly. Below is the <code
                class="hljs">IsSatisfied()</code> implementation. The templated <code class="hljs">Get()</code> function
              will be explained in the section on custom parameters.
            </p>

            <pre><code>bool IdAmountPrereqChecker::IsSatisfied(Prerequisite const& prereq) const
{
  unsigned int currentAmount = idAmountQuery(prereq.Get&lt;string>(string(PROP_PREREQ_ID)));
  unsigned int targetAmount = static_cast&lt;unsigned int>(prereq.Get&lt;int>(string(PROP_PREREQ_AMOUNT)));

  return currentAmount >= targetAmount;
}</code></pre>

            <p>
              The <code class="hljs">QuestManager</code> keeps track of a hashmap of each of its <code
                class="hljs">PrerequisiteChecker</code>s: <code
                class="hljs">std::unordered_map&lt;std::string, std::shared_ptr&lt;PrerequisiteChecker>> prereqCheckers;</code>.
              When the <code class="hljs">QuestManager::WithItemChecker()</code> function is called, a new <code
                class="hljs">IdAmountPrereqChecker</code> is
              created with the function provided, and an entry is added to the hashmap for the string "Has Items".
              Then
              on <code class="hljs">Update()</code>, for each of the inactive quests' prerequisites, based on the type
              (converted to a string), the
              the <code class="hljs">PrerequisiteChecker</code> is found in the hashmap, and its <code
                class="hljs">IsSatisfied()</code> function is executed (see the code under the Custom Checkers section).
            </p>

            <h3>Event System Implementation</h3>
            <p>
              Under the hood, <em>Bequestor</em> uses an Observer pattern [3]. An <code
                class="hljs">EventDispatcher</code> keeps track of a set of <code class="hljs">Observer</code>s and
              when
              its <code class="hljs">Notify()</code> function is called, it
              calls <code class="hljs">OnNotify()</code> on all of its <code class="hljs">Observer</code>s.
            </p>
            <p>
              From that point on, it works similarly to prerequisites. <code class="hljs">QuestManager</code> saves a
              hashmap of <code class="hljs">ObjectiveChecker</code>s: <code
                class="hljs">std::unordered_map&lt;std::string, std::shared_ptr&lt;ObjectiveChecker>> objectiveCheckers;</code>.
              For the preset objectives, since these don't require a specific query, these are already automatically
              created
              in the <code class="hljs">QuestManager</code>'s constructor.
            </p>
            <pre><code>QuestManager::QuestManager()
{
  //(...)
  objectiveCheckers.insert({OBJECTIVE_TYPE_TO_STRING.find(ObjectiveType::ITEM)->second, make_shared&lt;IdAmountObjectiveChecker>()});
  objectiveCheckers.insert({OBJECTIVE_TYPE_TO_STRING.find(ObjectiveType::CREATURE_KILL)->second, make_shared&lt;IdAmountObjectiveChecker>()});
  objectiveCheckers.insert({OBJECTIVE_TYPE_TO_STRING.find(ObjectiveType::LOCATION)->second, make_shared&lt;IdObjectiveChecker>()});
  objectiveCheckers.insert({OBJECTIVE_TYPE_TO_STRING.find(ObjectiveType::NPC)->second, make_shared&lt;IdObjectiveChecker>()});
}</code></pre>
            <p>
              In <code class="hljs">QuestManager::OnNotify()</code>, for each of the active quests' objectives, the
              <code class="hljs">ObjectiveChecker</code> is found in the hashmap and its <code
                class="hljs">OnEvent()</code>
              function is executed, passing along the event parameter. Furthermore, in the <code
                class="hljs">QuestManager::Update()</code> function, for each of the active quests' objectives, the
              <code class="hljs">IsSatisfied()</code> function is executed.
            </p>

            <h3>Custom Parameters</h3>
            <p>
              Under the hood, for objects with custom parameters, I use a <code class="hljs">Parameterized</code>
              class. In here, I simply keep track of a hashmap which maps from the paramater name to its value. Its
              value is stored as an <code class="hljs">std::variant</code>, and a templated <code
                class="hljs">Get()</code> function is used to retrieve the value of the correct type. <code
                class="hljs">Prerequisite</code>s as well as <code class="hljs">Objective</code>s extend this
              <code class="hljs">Parameterized</code> class. Below is the <code class="hljs">Parameterized</code>
              implementation:
            </p>

            <pre><code>class Parameterized
{
public:
  void AddParameter(std::string name, std::variant&lt;std::string, int, unsigned int, float, bool> value)
  {
    parameters.insert({name, value});
  };

  template &lt;typename Type>
  Type Get(std::string name) const
  {
    return std::get&lt;Type>(parameters.at(name));
  };

  // (...)

private:
  std::unordered_map&lt;std::string, std::variant&lt;std::string, int, unsigned int, float, bool>> parameters;
};</code></pre>

            <h3>Custom Checkers</h3>
            <p>
              In order to find the right <code class="hljs">PrerequisiteChecker</code> or <code
                class="hljs">ObjectiveChecker</code> in the appropriate hashmap, each custom checker is saved under
              its
              prerequisite/objective's custom type name (where preset checkers simply map from their enum to their
              index string). As an example of how this is used, see the <code
                class="hljs">QuestManager::checkPrerequisitesForQuest()</code> implemenation:
            </p>

            <pre><code>bool QuestManager::checkPrerequisitesForQuest(Quest const& quest) const
{
  for (auto const& prereq : quest.prerequisites)
  {
    string const& prereqStr = prereq->type == PrerequisiteType::CUSTOM ? prereq->customType : PREREQ_TYPE_TO_STRING.find(prereq->type)->second;
    auto const& result = prereqCheckers.find(prereqStr);
    if (result == prereqCheckers.end())
    {
      cerr &lt;&lt; "No prerequisite checker for " &lt;&lt; prereqStr &lt;&lt; " exists." &lt;&lt; endl; 
      return false; 
    }
    else if (!(result->second->IsSatisfied(*prereq))) return false;
  }
  return true;
}</code></pre>

            <h3>State Parameters</h3>

            <p>
              Custom objectives can also come with custom state parameters. These are registered along with the <code
                class="hljs">ObjectiveChecker</code>. They are saved in a multimap in <code
                class="hljs">QuestManager</code> that maps from the custom type to the parameters. These custom
              parameters are then passed along to the <code class="hljs">JsonReader::ReadQuests</code> function. Only
              in here are they actually added to the objective state as the objectives are read in.
            </p>

            <pre><code>vector&lt;shared_ptr&lt;Objective>> readObjectives(json objectivesJson,
                unordered_multimap&lt;string, pair&lt;string, variant&lt;string, int, unsigned int, float, bool>>> const& extraParameters)
{
  vector&lt;shared_ptr&lt;Objective>> objectives;
  for (json const& objectiveJson : objectivesJson)
  {
    shared_ptr&lt;Objective> objective = make_shared&lt;Objective>();
    objective->type = objectiveJson["type"].get&lt;ObjectiveType>();
    // (...)
    readParameters(objectiveJson["parameters"], objective);

    if (objective->type == ObjectiveType::CUSTOM)
    {
      objective->customType = objectiveJson["custom_type"];

      auto its = extraParameters.equal_range(objective->customType);
      for (auto& it = its.first; it != its.second; it++)
      objective->state->AddParameter(it->second.first, it->second.second);
    }

    objectives.push_back(objective);
  }
  // (...)
  return objectives;
}</code></pre>

            <h3>Dependencies</h3>
            <p>
              Under the hood, dependencies are stored as sets of sets of pointers to objectives: <code
                class="hljs">std::set&lt;std::set&lt;std::shared_ptr&lt;Objective>>> dependencies;</code> For each of
              the objectives, we set a status to <code class="hljs">UNAVAILABLE</code> at the start. Then for each of
              the unavailable objectives, we execute <code
                class="hljs">QuestManager::objectiveDependenciesAreMet()</code>, and if this returns <code
                class="hljs">true</code>, we set the objective status to <code class="hljs">ACTIVE</code>. I can make
              use of the <code class="hljs">std::all_of()</code> and <code class="hljs">std::any_of()</code>
              algorithms to easily specify that the dependencies are met if for any of them, all of the associated
              objectives are complete.
            </p>

            <pre><code>bool QuestManager::objectiveDependenciesAreMet(Objective const& objective, Quest const& quest) const
{
  return any_of(objective.dependencies.cbegin(),
                objective.dependencies.cend(),
                [&completedObjectives](set&lt;shared_ptr&lt;Objective>> const& dependency)
                {
                  return all_of(dependency.cbegin(),
                                dependency.cend(),
                                [](shared_ptr&lt;Objective> const& objective)
                                { return objective->state->status == ObjectiveStatus::SATISFIED; });
                });
}</code></pre>
          </div>

          <h2 id="q_conclusion">Conclusion</h2>
          <p>
            In what essentially has been the user guide for <em>Bequestor</em>, we have gone over all the features
            that
            the current version of the tool has to offer. We have created quests with prerequisites and objectives
            that
            can be preset ones or fully custom ones, and with possible optional objectives and dependencies between
            objectives. We have then exported these quests to a JSON, and imported them into our own game, using the
            <em>Bequestor</em> library. We also registered the necessary prerequisite and objective checkers, and
            parameters, and sent out the appropriate events so our quests update accordingly. Lastly, there was a
            section where we explored how I implemented this quest system under the hood. Hopefully, this all
            helps you to use this tool properly, and/or create your own quest tool.
          </p>

          <h2 id="q_references">References</h2>
          <table>
            <tr>
              <td>[1] <a href=https://github.com/nlohmann/json>https://github.com/nlohmann/json</a></td>
            </tr>
            <tr>
              <td>[2] <a
                  href=https://gameprogrammingpatterns.com/command.html>https://gameprogrammingpatterns.com/command.html</a>
              </td>
            </tr>
            <tr>
              <td>[3] <a
                  href=https://gameprogrammingpatterns.com/observer.html>https://gameprogrammingpatterns.com/observer.html</a>
              </td>
            </tr>
          </table>

        </div>
      </div>
    </section>

  </div> <!-- end s-pagewrap -->
  <!-- Java Script
    ================================================== -->
  <script src="js/plugins.js"></script>
  <script src="js/main.js"></script>
  <script src="js/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

</body>

</html>